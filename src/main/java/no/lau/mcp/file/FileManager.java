package no.lau.mcp.file;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public interface FileManager {
    Map<String, Path> listFilesWithGeneratedKeys() throws IOException;

    Path createNewFileWithAutoGeneratedNameInSecondFolder(String extension) throws IOException;

    Set<String> listVideoReferences();

    String replaceVideoReferences(String command);


    Logger log = LoggerFactory.getLogger(FileManager.class);
    static List<String> extractIds(String text) {
        Matcher matcher = Pattern.compile("\\{\\{([^{}]+)}}").matcher(text);

        List<String> ids = new ArrayList<>();
        while (matcher.find()) {
            // Extract just the ID part without the braces
            ids.add(matcher.group(1));
        }
        return ids;
    }

    /**
     * Replace video references in the command with their actual paths.
     * @param command The command with potential {{videoref}} placeholders
     * @return The command with resolved video references
     */
    static String replaceVideoReferences(String command, Map<String, Path> videoReferences)  {
        // First check for direct {{name}} references
        log.debug("Replace in FFmpeg command: " + command);

        for (String id : FileManager.extractIds(command)) {
            if (!videoReferences.containsKey(id)) {
                log.error("No video reference found for ID: " + id);
                throw new IllegalArgumentException("Video reference '" + id + "' not found.");
            }
            String path = videoReferences.get(id).toAbsolutePath().toString();
            command = command.replace("{{" + id + "}}", path);
        }
        // If we still have {{videoref}}, use the default replacement from FFmpegWrapper
        return command;
    }
}
